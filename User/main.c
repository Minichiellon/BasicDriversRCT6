/**==================================================================================================================
 **【文件名称】  main.c
 **【功能测试】  按键控制LED_使用扫描方法检测按键状态
 **==================================================================================================================
 **【实验平台】  STM32F103 + KEIL5.27
 **
 **【实验操作】  USB线，插到开发板CMSIS-DAP接口上;
 **              因使用的是板载的LED，因而无需其它接线及器材;
 **              点击软件左上角的编译，编译无错后，点击LOAD，即可烧录至开发板;
 **
 **【划 重 点】  KEY1，闲时低电平，按下时，是高电平
 **              KEY2和KEY3，闲时高电平，按下时是低电平
 **              先配置NVIC的优先级分组，再配置中断线优先级，最后中断线
 **              中断发生后，外部中断线是要手动清零的，否则会卡死在中断服务函数里出不来
 **
 **【更新记录】  2022-01-25  完善代码结构、注释
 **              2021-12-03  创建
 **
 **【备注说明】  版权归魔女科技所有，请勿商用，谢谢！
 **              https://demoboard.taobao.com
====================================================================================================================*/
#include <stm32f10x.h>                               // 头文件引用(标准库); 内核、芯片外设....;(stm32f10x.conf.h, 对标准库头文件进行调用)     
#include "stm32f10x_conf.h"                          // 头文件引用(标准库); 内核、芯片外设....;(stm32f10x.conf.h, 对标准库头文件进行调用) 
#include "system_f103.h"
#include "test.h"
#include "bspInc_conf.h"
#include "UsartCtlCan.h"


int main(void)                                       // 主函数, 整个工程的用户代码起始点
{
	uint16_t CAN1_baudrate = 125;
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  // 中断分组，组2:抢占级0~3,子优先级0~3 ; 全局只设置一次，尽量放在显眼的地方
    USART1_Init(115200);
    System_SysTickInit();
    Led_Init();                                      // LED初始化
    Key_Init();                                      // KEY初始化
    Timer_Init();
	System_DelayMS(200);
	//串口配置波特率方法：上位机一直发送ascii编码的数字，如：125、250等，然后按复位
	//如果不使用串口配置波特率的话，直接修改上面的变量
	if(xUSART.USART1ReceivedNum > 0)
	{
		CAN1_baudrate = (xUSART.USART1ReceivedData[0]-'0')*100 + (xUSART.USART1ReceivedData[1]-'0')*10 + xUSART.USART1ReceivedData[2]-'0';
		xUSART.USART1ReceivedNum = 0;
	}
    CAN1_Config(CAN1_baudrate);                                   // CAN1初始化
    
    
    while (1)                                        // while函数死循环，不能让main函数运行结束，否则会产生硬件错误
    {
//        Key_Led_test();
//        CheckKeyEvent(KEY_2);
//        Usart_test();
//        Can_test();
//        Timer_test();
        
        UsartCtlCan();
    } 
}




